//============================================================================
//                                  I B E X                                   
// File        : ibex_OptimSimplex.cpp_
// Author      : Ignacio Araya  Bertrand Neveu
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Jul 12, 2012
// Last Update : May 07, 2013
//============================================================================


#include "ibex_Optimizer.h"
#include <stdlib.h>


namespace ibex {



//The system is overconstrained by using the Taylor extension in one corner randomly chosen
//Then the simplex algorithm is applied to obtain a new upper bound loup
//If a new loup is found the method returns true

bool Optimizer::update_loup_simplex(const IntervalVector& box) {

	if (!(Interval(1.e-14,1.e6).contains(box.max_diam()))) return false;  // A extraire
	// is it necessary?  YES (BNE) Soplex can give false infeasible results with large numbers
	//cout << "[polytope-hull] box before LR (linear relaxation): " << box << endl;

	try {
		IntervalVector ext_box(box.size()+1,Interval(-1.e100,1.e100));
		write_ext_box(box, ext_box);
		// Update the bounds the variables
		mylp->initBoundVar(ext_box);

		//returns the number of constraints in the linearized system
		int cont = lr->linearization(ext_box, *mylp);
		//cout << "[polytope-hull] end of LR" << endl;
		if(cont<1)  return false;

		Interval opt(0.0);
		int i = lr->goal_var();

		LinearSolver::Status_Sol stat = mylp->run_simplex(ext_box, LinearSolver::MINIMIZE, i, opt,ext_box[i].lb());

		//	std::cout << " stat " << stat << std::endl;
		if (stat == LinearSolver::OPTIMAL) {
			//the linear solution is mapped to intervals and evaluated
			Vector prim(n+1);
			mylp->getPrimalSol(prim);

			//		std::cout << " simplex result " << tmpbox << std::endl;
			Vector prim_int(box.size());
			int i2=0;
			for (int i=0; i<n; i++,i2++) {
				if (i2==lr->goal_var()) i2++; // skip goal variable
				prim_int[i]=prim[i2];
			}
			bool ret= box.contains(prim_int) && check_candidate(prim_int,false); //  [gch] do we know here that the point is inner??

			if (ret) {
				if (trace) {
					int prec=std::cout.precision();
					std::cout.precision(12);
					std::cout << "[simplex1]"  << " loup update " << pseudo_loup  << " loup point  " << loup_point << std::endl;
					std::cout.precision(prec);
				}
				nb_simplex++;
				diam_simplex= ((nb_simplex-1) * diam_simplex + box.max_diam()) / nb_simplex;
			}

			mylp->cleanConst();
			return ret;
		}
		if (trace) {
			if(stat == LinearSolver::TIME_OUT) std::cout << "Simplex spent too much time" << std::endl;
			if(stat == LinearSolver::MAX_ITER) std::cout << "Simplex spent too many iterations" << std::endl;
		}

		mylp->cleanConst();
		return false;

	}
	catch(LPException&) {
		mylp->cleanConst();
		return false;
	}
	return false;

}

} // end namespace ibex
